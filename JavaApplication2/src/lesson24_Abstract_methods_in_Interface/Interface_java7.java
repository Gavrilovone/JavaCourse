package lesson24_Abstract_methods_in_Interface;
/**
 * Интерефейс может содержать в себе только константы (но мало кто использует константы в интерфейсе)
 * Интерфейс это контрукция языка программирования, который  часто сравнивают с контрактом.В этом контракте указано,
 * что класс может делать т.е какие методы в нем будут присутствовать, если он имплементирует данный интерфейс.Когда 
 * класс имплементирует какой либо интерфейс, он обязуется  снабдить методы этого интерфейса телами (перезаписать
 * абстрактные методы); в противном случае класс должен стать абстрактным.т.е если известно, что класс имплементирует 
 * какой либо интерфейс, то в этом классе гарантированно будут методы из интерфейса
 * 
 * Если говорить не о jave, то интерфейс вообще определяет разные пути с помощью которых допустим люди и какие то 
 * системы могут общаться.Например есть телефизор, интерфейс в данном случае это пульт илили кнопки на телевизоре или 
 * голосовое управление, интерфейс показывает какие операции можно сделать с телевизором
 * 
 * кто-то проводит параллели с абстрактным классом, мол интерфейс это кстремально абстрактный класс, но интерфейс не 
 * является классом 
 */


public class Interface_java7 {

    
}

class Employee {

    String name;
    int age;
    int experience;

    void eat() {
        System.out.println("Кушает");
    }

    void sleep() {
        System.out.println("Спит");
    }
}

class Teacher extends Employee implements Help_able {
    /**
     * класс может и не extend-ить какой-то класс, а только имплементрировать какой-то интерфейс, но если экстендит,
     * то синтаксис таков, что сначала пишется extends, а потом implements
     */

    int numberOfStudents;
    void teach() {
        System.out.println("Учит");
    }
    @Override
    public void Help(){ // если бы у метода интерфейса были параметры, то тут их тоже нужно было бы писать
        System.out.println("Учитель оказывает помощь");
    }
    @Override
    public void putOutTheFire(){
        System.out.println("Учитель тушит пожар");
    }
    /**
     * access modifier обязательно public, потому что по правилам  override он не может быть более строгий, а так как
     * у всех интерфейсов он public, то здесь он не может быть дефолтным или еще более строгим
     */

}
/**
 * Опять же, пока мы не сделаем класс абстрактным или не заоверайдим все методы интерфейса будет ошибка
 * Можно имплементировать сразу несколько интерфейсов через запятую:
 */
class Driver extends Employee implements Help_able, Swim_able{ 
    int machineName;
    void drive() {
        System.out.println("Водит");
    }
    @Override
    public void Help(){ 
        System.out.println("Водитель оказывает помощь");
    }
    @Override
    public void putOutTheFire(){
        System.out.println("Водитель тушит пожар");
    }
    @Override
    public void Swim(){
        System.out.println("Водитель плавает");
    }
}

interface Help_able{ // способный помогать
    void Help(); // так как у интерфеса могут быть только абстрактные методы, обычных методов с телами нет
    void putOutTheFire(); // метод тушить пожар тоже абстрактный
    /**
     * Просто в интерфейсе можно не писать слово abstract перед методом, компилятор подставит его вместо нас + он 
     * добавит еще access modifier public, потому что все методы в интерфейсе public
     */
}
interface Swim_able{ // умеет плавать
    void Swim();
    int a = 10;
    /**
     * если не писать самим, by default компилятор добавит public final static int a = 10 
     * и в дальнейшем мы не сможем изменить переменную a, потому что a это константа
     */
}


